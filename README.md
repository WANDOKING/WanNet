자작 IOCP 네트워크 라이브러리 WanNet
======================================

서버 스레드 설계
-------------------------------- 
1. Accept Thread X 1 : 서버의 Accept 처리를 전담
2. Monitor Thread X 1 : 초마다 서버의 모니터링 정보를 갱신
3. IOCP Worker Thread X N : PQCS를 호출, Send, Recv 완료 통지에 따른 작업 수행

##

라이브러리 사용법
--------------------------------
### 1. NetServer를 상속받은 서버 클래스를 구현
### 2. NetClient를 상속받은 클라이언트 클래스를 구현 (서버간 통신에 활용하고자 개발)
### 3. Serializer 클래스의 static 멤버 함수 Alloc()을 통해 할당, Free()로 해제

구현 특이점
--------------------------------
#### 1. 컨텐츠 영역에서 세션의 ID와 조립된 패킷만을 노출시킨다
  + 세션 포인터를 노출시키지 않음으로써 좀 더 안정적인 설계를 목표로하였음
#### 2. 내부에서 동기화 객체를 사용하지 않았음
  + 각 세션의 SendQueue는 락-프리 큐로 개발
  + 각 세션의 릴리즈 동기화 문제는 IoCount와 Release Flag를 조합하는 방식으로 구현하였음
  + 세션 리스트 내부의 세션은 세션 풀 형태로 관리되며, 릴리즈된 세션의 인덱스를 락-프리 스택에 반환하는 구조

그 외 클래스들 부연 설명
--------------------------------
#### 1. CrashDump : 크래스 발생 시 프로세스 덤프를 남기기 위한 클래스
  + CRT 함수의 에러 핸들러 등을 교체하여 내 에외 핸들러 코드가 돌도록 하였음
  + MiniDumpWriteDump() 함수를 이용해 프로세스 덤프 생성

#### 2. Logger : 개발용 시스템 로그
  + 설정된 로깅 수준에 따라 텍스트 파일에 로깅
  + ASSERT_LIVE()를 통해 비정상 상황 시 로깅 후 크래시

#### 3. TlsObjectPool
  + 기본적으로는 Free List 방식의 오브젝트 풀
  + 스레드간 경합으로 인한 성능 손실을 최소화 하기 위해 각 스레드가 큰 덩어리(청크)를 할당 받아 사용
  + 중앙 풀 매니저로부터 청크를 할당/반환 할 때만 락을 걸고 접근
  + 성능 테스트 시 Alloc은 New보다 최대 18배, Free는 Delete보다 최대 6배 빨랐음

#### 4. Serializer
  + 직렬화 버퍼 클래스, static 멤버 함수로만 할당 / 해제하도록 하여 항상 TLS 오브젝트 풀을 사용
  + 패킷에 대한 간단한 암호화, 복호화 수행 (게임의 프로토콜 분석을 어렵게 하기 위한 목적)
